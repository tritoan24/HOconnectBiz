import 'dart:io';
import 'dart:math';

import 'package:clbdoanhnhansg/config/app_config.dart';
import 'package:clbdoanhnhansg/providers/post_provider.dart';
import 'package:clbdoanhnhansg/providers/product_provider.dart';
import 'package:clbdoanhnhansg/providers/rank_provider.dart';
import 'package:clbdoanhnhansg/providers/user_provider.dart';
import 'package:clbdoanhnhansg/widgets/loading_overlay.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_facebook_auth/flutter_facebook_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:go_router/go_router.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:onesignal_flutter/onesignal_flutter.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:developer' as developer;
import 'package:sign_in_with_apple/sign_in_with_apple.dart';
import '../core/base/base_provider.dart';
import '../core/network/api_endpoints.dart';
import '../core/services/socket_service.dart';
import '../models/apiresponse.dart';
import '../repository/auth_repository.dart';
import '../utils/router/router.dart';
import '../utils/router/router.name.dart';

class AuthProvider extends BaseProvider {
  final AuthRepository _authRepository = AuthRepository();
  final FlutterSecureStorage _storage = const FlutterSecureStorage();
  final socketService = SocketService();

  // Th√™m getter isLoggedIn
  bool _isLoggedIn = false;
  bool get isLoggedIn => _isLoggedIn;

  // Th√™m ph∆∞∆°ng th·ª©c getToken public
  Future<String?> getToken() async {
    return _getToken();
  }

  Future<void> _saveToken(String token) async {
    try {
      // L∆∞u v√†o FlutterSecureStorage
      await _storage.write(key: 'auth_token', value: token);

      // L∆∞u v√†o SharedPreferences nh∆∞ backup
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('auth_token', token);
    } catch (e) {
      print('L·ªói l∆∞u token: $e');
      // N·∫øu FlutterSecureStorage l·ªói, ch·ªâ l∆∞u v√†o SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('auth_token', token);
    }
  }

  Future<void> _saveUserId(String id) async {
    try {
      // L∆∞u v√†o FlutterSecureStorage
      await _storage.write(key: 'user_id', value: id);

      // L∆∞u v√†o SharedPreferences nh∆∞ backup
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user_id', id);

      if (kDebugMode) {
        print("üîë id user: $id");
      }
    } catch (e) {
      print('L·ªói l∆∞u user ID: $e');
      // N·∫øu FlutterSecureStorage l·ªói, ch·ªâ l∆∞u v√†o SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user_id', id);
    }
  }

  Future<String?> _getToken() async {
    try {
      // Th·ª≠ l·∫•y t·ª´ FlutterSecureStorage tr∆∞·ªõc
      final secureToken = await _storage.read(key: 'auth_token');
      if (secureToken != null) return secureToken;

      // N·∫øu kh√¥ng c√≥, l·∫•y t·ª´ SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString('auth_token');
    } catch (e) {
      print('L·ªói ƒë·ªçc token: $e');
      // N·∫øu FlutterSecureStorage l·ªói, l·∫•y t·ª´ SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString('auth_token');
    }
  }

  Future<String?> getuserID() async {
    try {
      // Th·ª≠ l·∫•y t·ª´ FlutterSecureStorage tr∆∞·ªõc
      final secureId = await _storage.read(key: 'user_id');
      if (secureId != null) return secureId;

      // N·∫øu kh√¥ng c√≥, l·∫•y t·ª´ SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString('user_id');
    } catch (e) {
      print('L·ªói ƒë·ªçc user ID: $e');
      // N·∫øu FlutterSecureStorage l·ªói, l·∫•y t·ª´ SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString('user_id');
    }
  }

  Future<void> clearAllData() async {
    try {
      // X√≥a d·ªØ li·ªáu t·ª´ FlutterSecureStorage
      await _storage.delete(key: 'auth_token');
      await _storage.delete(key: 'user_id');

      // X√≥a d·ªØ li·ªáu t·ª´ SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('auth_token');
      await prefs.remove('user_id');
    } catch (e) {
      print('L·ªói x√≥a d·ªØ li·ªáu: $e');
      // N·∫øu FlutterSecureStorage l·ªói, ch·ªâ x√≥a t·ª´ SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('auth_token');
      await prefs.remove('user_id');
    }
  }

  Future<void> checkLoginStatusWithoutRedirect(BuildContext context) async {
    try {
      setLoading(true);
      final token = await _getToken();

      if (token != null && token.isNotEmpty) {
        try {
          // Make API call to validate token
          await Provider.of<UserProvider>(context, listen: false)
              .fetchUser(context, showLoading: false);

          _isLoggedIn = true;

          // Connect socket
          final userId = await getuserID();
          if (userId != null) {
            socketService.connect(userId);
            socketService.connectUserStatus();
          }
        } catch (userError) {
          debugPrint("L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng: $userError");
          _isLoggedIn = false;

          // Explicitly clear data on token validation failure
          await clearAllDataIOS();

          // Make sure to throw the error so it can be caught
          throw Exception('Token validation failed: $userError');
        }
      } else {
        _isLoggedIn = false;
      }
    } catch (e) {
      _isLoggedIn = false;
      setError("L·ªói ki·ªÉm tra ƒëƒÉng nh·∫≠p: $e");
      throw e; // Re-throw for splash screen to handle
    } finally {
      setLoading(false);
    }
  }

// Th√™m h√†m x√≥a d·ªØ li·ªáu tr√™n iOS
  Future<void> clearAllDataIOS() async {
    try {
      // Clear secure storage (FlutterSecureStorage or similar)
      final storage = FlutterSecureStorage();
      await storage.deleteAll();

      // If using SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.clear();

      // Reset state
      _isLoggedIn = false;
      // _token = null;
      notifyListeners();
    } catch (e) {
      print('Error clearing iOS data: $e');
    }
  }
  //
  // Future<void> checkLoginStatus(BuildContext context) async {
  //   try {
  //     // B·∫Øt ƒë·∫ßu loading
  //     setLoading(true);
  //     // Record start time
  //     final startTime = DateTime.now();
  //
  //     final token = await _getToken();
  //
  //     if (token != null && token.isNotEmpty) {
  //       // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
  //       _isLoggedIn = true;
  //
  //       // Get user ID for socket connection
  //       final userId = await getuserID();
  //
  //       if (userId != null) {
  //         // Connect to socket if we have a user ID
  //         socketService.connect(userId);
  //       }
  //
  //       if (!context.mounted) return;
  //
  //       try {
  //         // Try to fetch user data specifically
  //         await Provider.of<UserProvider>(context, listen: false)
  //             .fetchUser(context);
  //       } catch (userError) {
  //         // If user fetch fails, log the user out
  //         debugPrint("L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng: $userError");
  //
  //         // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
  //         _isLoggedIn = false;
  //
  //         // Clear token (optional)
  //         await _clearAllData();
  //
  //         if (context.mounted) {
  //           clearState();
  //           context.go(AppRoutes.login);
  //         }
  //         return; // Exit early
  //       }
  //
  //       if (!context.mounted) return;
  //
  //       // Proceed with other data fetching since user fetch succeeded
  //       final futures = <Future>[];
  //
  //       // Add remaining fetch tasks
  //       futures.add(Provider.of<ProductProvider>(context, listen: false)
  //           .getListProduct(context));
  //
  //       final postProvider = Provider.of<PostProvider>(context, listen: false);
  //
  //       futures.add(postProvider.fetchPostsFeatured(context));
  //       futures.add(postProvider.fetchPostsByUser(context));
  //
  //       // Wait for the remaining futures
  //       await Future.wait(futures);
  //
  //       // Ch·ªâ chuy·ªÉn h∆∞·ªõng sau khi t·∫•t c·∫£ fetch data ƒë√£ ho√†n th√†nh
  //       if (context.mounted) {
  //         // X√≥a l·ªói tr∆∞·ªõc khi chuy·ªÉn m√†n h√¨nh
  //         clearState();
  //
  //         // Chuy·ªÉn h∆∞·ªõng ƒë·∫øn ƒë√∫ng route
  //         context.go(AppRoutes.trangChu);
  //       }
  //     } else {
  //       // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
  //       _isLoggedIn = false;
  //
  //       // Ensure minimum 3 seconds even for login routing
  //       final elapsedMs = DateTime.now().difference(startTime).inMilliseconds;
  //       final remainingMs = 3000 - elapsedMs;
  //       if (remainingMs > 0) {
  //         await Future.delayed(Duration(milliseconds: remainingMs));
  //       }
  //
  //       if (context.mounted) {
  //         clearState();
  //         context.go(AppRoutes.login);
  //       }
  //     }
  //   } catch (e) {
  //     // ƒê·∫£m b·∫£o c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒëƒÉng nh·∫≠p khi c√≥ l·ªói
  //     _isLoggedIn = false;
  //
  //     setError("L·ªói ƒëi·ªÅu h∆∞·ªõng: $e");
  //     // N·∫øu c√≥ l·ªói, chuy·ªÉn v·ªÅ trang login
  //     if (context.mounted) {
  //       context.go(AppRoutes.login);
  //     }
  //   } finally {
  //     // K·∫øt th√∫c loading trong m·ªçi tr∆∞·ªùng h·ª£p
  //     setLoading(false);
  //   }
  // }

  Future<void> login(
      BuildContext context, String username, String password) async {
    try {
      // Hi·ªÉn th·ªã loading overlay
      LoadingOverlay.show(context);

      // ƒê√°nh d·∫•u ƒë·ªÉ kh√¥ng ·∫©n LoadingOverlay nhi·ªÅu l·∫ßn
      bool loadingHidden = false;

      void hideLoadingOnce() {
        if (!loadingHidden) {
          LoadingOverlay.hide();
          loadingHidden = true;
        }
      }

      await executeApiCall(
        apiCall: () => _authRepository.login(username, password, context),
        context: context,
        onSuccess: () async {
          final token = user!.token!;
          final idUser = user!.idUser!;
          await _saveToken(token);
          await _saveUserId(idUser);

          // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
          _isLoggedIn = true;

          OneSignal.login(username);
          socketService.connect(idUser);
          socketService.connectUserStatus();

          // T·∫°o danh s√°ch c√°c Future ƒë·ªÉ theo d√µi
          final futures = <Future>[];
          if (!context.mounted) return;
          // Th√™m c√°c t√°c v·ª• fetch d·ªØ li·ªáu v√†o danh s√°ch
          futures.add(Provider.of<UserProvider>(context, listen: false)
              .fetchUser(context));
          futures.add(Provider.of<ProductProvider>(context, listen: false)
              .getListProduct(context));

          final postProvider =
              Provider.of<PostProvider>(context, listen: false);
          // final rankProvider =
          //     Provider.of<RankProvider>(context, listen: false);
          //
          // futures.add(rankProvider.fetchRanksRevenue(context));
          // futures.add(rankProvider.fetchRankBusiness(context));

          futures.add(postProvider.fetchPostsFeatured(context));
          futures.add(postProvider.fetchPostsByUser(context));

          // Ch·ªù t·∫•t c·∫£ c√°c t√°c v·ª• ho√†n th√†nh
          await Future.wait(futures);

          if (context.mounted) {
            // ·∫®n loading overlay
            hideLoadingOnce();
            // X√≥a l·ªói tr∆∞·ªõc khi chuy·ªÉn m√†n h√¨nh
            clearState();
            context.go(AppRoutes.trangChu);
          }
        },
      );

      // N·∫øu c√≥ l·ªói, ƒë·∫£m b·∫£o ·∫©n loading
      if (errorMessage != null) {
        hideLoadingOnce();
      }
    } catch (e) {
      // ƒê·∫£m b·∫£o ·∫©n loading trong m·ªçi tr∆∞·ªùng h·ª£p l·ªói
      LoadingOverlay.hide();
      debugPrint("L·ªói ƒëƒÉng nh·∫≠p: $e");

      // Set error message t·ª´ exception
      setError(e.toString());
    }
  }

  Future<void> register(
    BuildContext context,
    String identity,
    String password,
    String repassword,
    String displayName,
  ) async {
    await executeApiCall(
      apiCall: () => _authRepository.register(
          identity, password, repassword, displayName, context),
      context: context,
      onSuccess: () async {
        setSuccess("T·∫°o t√†i kho·∫£n th√†nh c√¥ng!");
        clearState();

        // Ki·ªÉm tra ƒë·ªãnh d·∫°ng c·ªßa identity
        if (isEmail(identity)) {
          OneSignal.User.addEmail(identity);
        } else if (isPhoneNumber(identity)) {
          OneSignal.User.addSms(
              formatPhoneNumber(identity)); // T·ª± ƒë·ªông th√™m +84
        } else {
          debugPrint("Identity kh√¥ng h·ª£p l·ªá: $identity"); // Log l·ªói n·∫øu c·∫ßn
        }

        Future.delayed(const Duration(seconds: 1), () {
          if (context.mounted) {
            context.go(AppRoutes.login,
                extra: {"identity": identity, "password": password});
          }
        });
      },
    );
  }

// H√†m ki·ªÉm tra email
  bool isEmail(String input) {
    final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+$');
    return emailRegex.hasMatch(input);
  }

// H√†m ki·ªÉm tra s·ªë ƒëi·ªán tho·∫°i (kh√¥ng c·∫ßn m√£ qu·ªëc gia)
  bool isPhoneNumber(String input) {
    final phoneRegex = RegExp(r'^[0-9]{9,11}$');
    return phoneRegex.hasMatch(input);
  }

// H√†m ƒë·ªãnh d·∫°ng s·ªë ƒëi·ªán tho·∫°i: Th√™m +84 n·∫øu ch∆∞a c√≥ m√£ qu·ªëc gia
  String formatPhoneNumber(String phoneNumber) {
    phoneNumber = phoneNumber.trim();
    if (phoneNumber.startsWith('0')) {
      phoneNumber = phoneNumber.substring(1);
    }
    if (!phoneNumber.startsWith('+')) {
      return '+84$phoneNumber';
    }
    return phoneNumber;
  }

  Future<void> logout(BuildContext context) async {
    // Show loading overlay at the beginning
    LoadingOverlay.show(context);

    try {
      await executeApiCall(
        apiCall: () async {
          // X√≥a d·ªØ li·ªáu t·ª´ c·∫£ hai storage
          await clearAllData();

          // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
          _isLoggedIn = false;

          // L·∫•y registerType t·ª´ SharedPreferences
          final SharedPreferences prefs = await SharedPreferences.getInstance();
          final String? registerType = prefs.getString('register_type');

          if (registerType == null) {
            developer.log('Kh√¥ng t√¨m th·∫•y registerType trong storage',
                name: 'LOGOUT.ERROR');
          } else if (registerType == 'gg') {
            try {
              developer.log('B·∫Øt ƒë·∫ßu qu√° tr√¨nh ƒëƒÉng xu·∫•t Google',
                  name: 'LOGOUT_GOOGLE');

              // ƒêƒÉng xu·∫•t Google
              final GoogleSignIn googleSignIn = GoogleSignIn(
                scopes: [
                  'email',
                  'https://www.googleapis.com/auth/userinfo.profile'
                ],
                clientId: Platform.isIOS ? AppConfig.clientIdIos : null,
              );

              developer.log('Ki·ªÉm tra phi√™n ƒëƒÉng nh·∫≠p hi·ªán t·∫°i...',
                  name: 'LOGOUT_GOOGLE');
              // Ki·ªÉm tra xem c√≥ ƒëang ƒëƒÉng nh·∫≠p kh√¥ng
              final currentUser = await googleSignIn.signInSilently();

              if (currentUser != null) {
                developer.log(
                    'T√¨m th·∫•y ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p: ${currentUser.email}',
                    name: 'LOGOUT_GOOGLE');

                try {
                  developer.log('Th·ª±c hi·ªán disconnect()...',
                      name: 'LOGOUT_GOOGLE');
                  await googleSignIn.disconnect();
                  developer.log('ƒê√£ th·ª±c hi·ªán disconnect th√†nh c√¥ng',
                      name: 'LOGOUT_GOOGLE');
                } catch (disconnectError) {
                  developer.log('L·ªói khi disconnect: $disconnectError',
                      name: 'LOGOUT_GOOGLE_ERROR');
                }

                try {
                  developer.log('Th·ª±c hi·ªán signOut()...',
                      name: 'LOGOUT_GOOGLE');
                  await googleSignIn.signOut();
                  developer.log('ƒê√£ th·ª±c hi·ªán signOut th√†nh c√¥ng',
                      name: 'LOGOUT_GOOGLE');
                } catch (signOutError) {
                  developer.log('L·ªói khi signOut: $signOutError',
                      name: 'LOGOUT_GOOGLE_ERROR');
                }

                // ƒê·∫£m b·∫£o x√≥a register_type
                await prefs.remove('register_type');
                developer.log('ƒê√£ x√≥a register_type', name: 'LOGOUT_GOOGLE');

                developer.log('Qu√° tr√¨nh ƒëƒÉng xu·∫•t Google ho√†n t·∫•t',
                    name: 'LOGOUT_GOOGLE');
              } else {
                developer.log('Kh√¥ng t√¨m th·∫•y phi√™n ƒëƒÉng nh·∫≠p Google hi·ªán t·∫°i',
                    name: 'LOGOUT_GOOGLE');
              }

              // Ki·ªÉm tra l·∫°i sau khi ƒëƒÉng xu·∫•t
              final checkUser = await googleSignIn.signInSilently();
              developer.log(
                  'Ki·ªÉm tra sau ƒëƒÉng xu·∫•t: ${checkUser == null ? "ƒê√£ ƒëƒÉng xu·∫•t th√†nh c√¥ng" : "V·∫´n c√≤n ƒëƒÉng nh·∫≠p"}',
                  name: 'LOGOUT_GOOGLE');
            } catch (e) {
              developer.log('L·ªói trong qu√° tr√¨nh ƒëƒÉng xu·∫•t Google: $e',
                  name: 'LOGOUT_GOOGLE_ERROR', error: e);
            }
          } else if (registerType == 'fb') {
            // ƒê·∫£m b·∫£o x√≥a register_type
            await prefs.remove('register_type');
            await FacebookAuth.instance.logOut();
            developer.log('ƒê√£ ƒëƒÉng xu·∫•t Facebook',
                name: 'PROFILE_LOGOUT.FACEBOOK');
          } else if (registerType == 'apple') {
            // ƒê·ªëi v·ªõi Apple Sign In, ch·ªâ c·∫ßn x√≥a register_type v√¨ kh√¥ng c√≥ API ƒëƒÉng xu·∫•t c·ª• th·ªÉ
            await prefs.remove('register_type');
            developer.log('ƒê√£ ƒëƒÉng xu·∫•t Apple', name: 'PROFILE_LOGOUT.APPLE');
          }

          // ƒêƒÉng xu·∫•t OneSignal
          OneSignal.logout();

          // X√≥a t·∫•t c·∫£ d·ªØ li·ªáu t·ª´ SharedPreferences
          await prefs.clear();

          return ApiResponse(isSuccess: true, message: "ƒêƒÉng xu·∫•t th√†nh c√¥ng");
        },
        context: context,
        onSuccess: () {
          clearState();
          context.go(AppRoutes.login);
        },
      );
    } catch (e) {
      developer.log('L·ªói trong qu√° tr√¨nh ƒëƒÉng xu·∫•t: $e',
          name: 'LOGOUT_ERROR', error: e);
    } finally {
      // Hide loading overlay regardless of success or failure
      LoadingOverlay.hide();
    }
  }

  Future<void> sendEmailOtp(
      BuildContext context, String email, bool? isShow) async {
    await executeApiCall(
      apiCall: () => _authRepository.sendOtpEmail(email, context),
      context: context,
      onSuccess: () {
        // X√≥a l·ªói tr∆∞·ªõc khi chuy·ªÉn m√†n h√¨nh
        clearState();
        context.push(AppRoutes.nhapMaOTP,
            extra: {'email': email, 'isShow': isShow});
      },
    );
  }

  Future<void> reSendEmailOtp(BuildContext context, String email) async {
    await executeApiCall(
      apiCall: () => _authRepository.sendOtpEmail(email, context),
      context: context,
      onSuccess: () {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text(
              'M√£ x√°c th·ª±c ƒë√£ ƒë∆∞·ª£c g·ª≠i l·∫°i th√†nh c√¥ng',
              style: TextStyle(color: Colors.white),
            ),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      },
    );
  }

  Future<void> inputOtp(
      BuildContext context, String email, String code, bool? isShow) async {
    context
        .go(AppRoutes.taoMatKhauMoi, extra: {"email": email, "isShow": isShow});
    await executeApiCall(
      apiCall: () async {
        final response = await _authRepository.inputOtp(email, code, context);
        if (kDebugMode) {
          print("d·ªØ li·ªáu nh·∫≠p : $email - $code");
          print(
              "K·∫øt qu·∫£ x√°c th·ª±c m√£ OTP: ${response.message} - ${response.isSuccess}");
        }

        return response;
      },
      context: context,
      onSuccess: () {
        // X√≥a l·ªói tr∆∞·ªõc khi chuy·ªÉn m√†n h√¨nh
        clearState();
        context.go(AppRoutes.taoMatKhauMoi,
            extra: {"email": email, "isShow": isShow});
      },
    );
  }

  Future<void> resetpassword(
    BuildContext context,
    String email,
    String password,
    String repassword,
  ) async {
    await executeApiCall(
      apiCall: () =>
          _authRepository.resetpassword(email, password, repassword, context),
      context: context,
      onSuccess: () {
        // X√≥a l·ªói tr∆∞·ªõc khi chuy·ªÉn m√†n h√¨nh
        clearState();
        context.go(AppRoutes.login);
      },
      successMessage: "ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng",
    );
  }

  Future<void> changePassword(
    BuildContext context,
    String password,
    String newpassword,
    String repassword,
  ) async {
    await executeApiCall(
      apiCall: () => _authRepository.changepassword(
          password, newpassword, repassword, context),
      context: context,
      onSuccess: () {
        // X√≥a l·ªói tr∆∞·ªõc khi chuy·ªÉn m√†n h√¨nh
        clearState();
        context.pop();
      },
      successMessage: "ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng",
    );
  }

  Future<void> signInWithGoogle(BuildContext context) async {
    const String tag = 'GOOGLE_LOGIN';
    const String registerTypeGG = 'gg';
    const String defaultImage = UrlImage.defaultAvatarImage;

    try {
      // Hi·ªÉn th·ªã loading overlay
      LoadingOverlay.show(context);

      developer.log('B·∫Øt ƒë·∫ßu ƒëƒÉng nh·∫≠p Google', name: tag);
      developer.log('Ki·ªÉm tra CLIENT_IOS:', name: AppConfig.clientIdIos);

      final GoogleSignIn googleSignIn = GoogleSignIn(
          scopes: ['email', 'https://www.googleapis.com/auth/userinfo.profile'],
          clientId: Platform.isIOS ? AppConfig.clientIdIos : null);
      final GoogleSignInAccount? googleUser = await googleSignIn.signIn();

      if (googleUser == null) {
        developer.log('Ng∆∞·ªùi d√πng h·ªßy ƒëƒÉng nh·∫≠p', name: '$tag.CANCELLED');
        // ·∫®n loading overlay n·∫øu ng∆∞·ªùi d√πng h·ªßy ƒëƒÉng nh·∫≠p
        LoadingOverlay.hide();
        return;
      }
      developer.log('ƒêƒÉng nh·∫≠p th√†nh c√¥ng', name: '$tag.SUCCESS');

      final userData = {
        'id': googleUser.id,
        'email': googleUser.email,
        'name': googleUser.displayName ?? 'User',
        'picture': googleUser.photoUrl ?? defaultImage,
      };
      developer.log('Th√¥ng tin ng∆∞·ªùi d√πng: $userData', name: '$tag.USER_DATA');

      if (context.mounted) {
        _handleLoginSocialSuccess(context, userData, registerTypeGG);
      } else {
        // ·∫®n loading overlay n·∫øu context kh√¥ng c√≤n h·ª£p l·ªá
        LoadingOverlay.hide();
      }
    } catch (e) {
      developer.log('L·ªói ƒëƒÉng nh·∫≠p Google: $e', name: '$tag.ERROR', error: e);
      // ·∫®n loading overlay n·∫øu c√≥ l·ªói
      LoadingOverlay.hide();
    }
  }

  Future<void> signInWithApple(BuildContext context) async {
    const String tag = 'APPLE_LOGIN';
    const String registerTypeApple = 'apple';
    const String defaultImage = UrlImage.defaultAvatarImage;

    if (!Platform.isIOS) {
      developer.log('ƒêƒÉng nh·∫≠p Apple ch·ªâ h·ªó tr·ª£ tr√™n iOS',
          name: '$tag.PLATFORM_NOT_SUPPORTED');
      return;
    }

    try {
      // Hi·ªÉn th·ªã loading overlay
      LoadingOverlay.show(context);

      developer.log('B·∫Øt ƒë·∫ßu ƒëƒÉng nh·∫≠p Apple', name: tag);

      // Y√™u c·∫ßu c√°c th√¥ng tin c·∫ßn thi·∫øt t·ª´ Apple
      final credential = await SignInWithApple.getAppleIDCredential(
        scopes: [
          AppleIDAuthorizationScopes.email,
          AppleIDAuthorizationScopes.fullName,
        ],
      );

      if (credential.userIdentifier == null) {
        developer.log('Kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin ng∆∞·ªùi d√πng Apple',
            name: '$tag.NO_USER_ID');
        LoadingOverlay.hide();
        return;
      }

      developer.log('ƒêƒÉng nh·∫≠p Apple th√†nh c√¥ng', name: '$tag.SUCCESS');

      // L·∫•y th√¥ng tin t·ª´ credential
      final String userId = credential.userIdentifier ?? '';
      final String? givenName = credential.givenName;
      final String? familyName = credential.familyName;
      final String? email = credential.email;

      // T·∫°o display name t·ª´ t√™n ho·∫∑c d√πng m·∫∑c ƒë·ªãnh
      String displayName = 'Apple User';
      if (givenName != null || familyName != null) {
        displayName = '${givenName ?? ''} ${familyName ?? ''}'.trim();
      }

      developer.log('UserId: $userId, Email: $email, Name: $displayName',
          name: '$tag.USER_DATA');

      // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p ·∫©n danh (kh√¥ng chia s·∫ª email)
      String userEmail;
      if (email != null && email.isNotEmpty) {
        // N·∫øu c√≥ email th·∫≠t, s·ª≠ d·ª•ng email ƒë√≥
        userEmail = email;
      } else {
        // T·∫°o email gi·∫£ nh∆∞ng ƒë·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° 64 k√Ω t·ª±
        // T·∫°o hash ng·∫Øn t·ª´ userId
        String hash = userId.hashCode.toString().replaceAll('-', '');
        hash = hash.length > 10 ? hash.substring(0, 10) : hash;
        userEmail = 'apple${hash}@example.com';
      }

      // Ki·ªÉm tra l·∫°i ƒë·ªô d√†i email
      if (userEmail.length > 64) {
        // N·∫øu v·∫´n qu√° d√†i, t·∫°o phi√™n b·∫£n ng·∫Øn h∆°n
        userEmail =
            'apple${DateTime.now().millisecondsSinceEpoch % 1000000}@ex.com';
      }

      developer.log('Email cu·ªëi c√πng: $userEmail, ƒê·ªô d√†i: ${userEmail.length}',
          name: '$tag.EMAIL');

      Map<String, dynamic> userData = {
        'id': userId,
        'email': userEmail,
        'name': displayName,
        'picture': defaultImage,
      };

      if (context.mounted) {
        _handleLoginSocialSuccess(context, userData, registerTypeApple);
      } else {
        // ·∫®n loading overlay n·∫øu context kh√¥ng c√≤n h·ª£p l·ªá
        LoadingOverlay.hide();
      }
    } catch (e) {
      developer.log('L·ªói ƒëƒÉng nh·∫≠p Apple: $e', name: '$tag.ERROR', error: e);
      // ·∫®n loading overlay n·∫øu c√≥ l·ªói
      LoadingOverlay.hide();
    }
  }

  Future<void> signInWithFacebook(BuildContext context) async {
    const String tag = 'FB_LOGIN';
    const String registerTypeFB = 'fb';

    try {
      // Hi·ªÉn th·ªã loading overlay
      LoadingOverlay.show(context);

      developer.log('B·∫Øt ƒë·∫ßu ƒëƒÉng nh·∫≠p Facebook', name: tag);
      final LoginResult result = await FacebookAuth.instance.login(
        permissions: ['email', 'public_profile'],
      );

      switch (result.status) {
        case LoginStatus.success:
          developer.log(
            'ƒêƒÉng nh·∫≠p th√†nh c√¥ng',
            name: '$tag.SUCCESS',
          );
          developer.log('ƒêang l·∫•y th√¥ng tin ng∆∞·ªùi d√πng...',
              name: '$tag.USER_DATA');
          final userData = await FacebookAuth.instance.getUserData(
            fields: "name,email,picture.width(200)",
          );
          developer.log('Th√¥ng tin ng∆∞·ªùi d√πng: $userData',
              name: '$tag.USER_DATA');
          if (context.mounted) {
            _handleLoginSocialSuccess(context, userData, registerTypeFB);
          } else {
            // ·∫®n loading overlay n·∫øu context kh√¥ng c√≤n h·ª£p l·ªá
            LoadingOverlay.hide();
          }
          break;

        case LoginStatus.cancelled:
          developer.log('Ng∆∞·ªùi d√πng h·ªßy ƒëƒÉng nh·∫≠p', name: '$tag.CANCELLED');
          _handleLoginIssue(
            message: 'X·ª≠ l√Ω h·ªßy ƒëƒÉng nh·∫≠p',
            tag: '$tag.CANCELLED',
          );
          // ·∫®n loading overlay n·∫øu ng∆∞·ªùi d√πng h·ªßy ƒëƒÉng nh·∫≠p
          LoadingOverlay.hide();
          break;

        case LoginStatus.failed:
          developer.log('ƒêƒÉng nh·∫≠p th·∫•t b·∫°i - L·ªói: ${result.message}',
              name: '$tag.FAILED');
          _handleLoginIssue(
            message: 'X·ª≠ l√Ω th·∫•t b·∫°i: ${result.message}',
            tag: '$tag.FAILED',
          );
          // ·∫®n loading overlay n·∫øu ƒëƒÉng nh·∫≠p th·∫•t b·∫°i
          LoadingOverlay.hide();
          break;

        default:
          developer.log('Tr·∫°ng th√°i kh√¥ng x√°c ƒë·ªãnh: ${result.status}',
              name: '$tag.UNKNOWN');
          // ·∫®n loading overlay trong tr∆∞·ªùng h·ª£p kh√¥ng x√°c ƒë·ªãnh
          LoadingOverlay.hide();
      }
    } catch (e) {
      developer.log('L·ªói h·ªá th·ªëng: $e', name: '$tag.ERROR', error: e);
      _handleLoginIssue(
        message: 'X·ª≠ l√Ω l·ªói: $e',
        tag: '$tag.ERROR',
        error: e,
      );
      // ·∫®n loading overlay n·∫øu c√≥ l·ªói
      LoadingOverlay.hide();
    }
  }

  Future<void> _handleLoginSocialSuccess(BuildContext context,
      Map<String, dynamic> userData, String registerType) async {
    // ƒê·∫∑t tag d·ª±a tr√™n registerType
    final String tag = registerType == 'fb'
        ? 'FB_LOGIN.SUCCESS'
        : (registerType == 'apple'
            ? 'APPLE_LOGIN.SUCCESS'
            : 'GG_LOGIN.SUCCESS');
    final String? id = userData['id'];
    final String? name = userData['name'];
    final String? email = userData['email'];
    String? avatarImage;

    if (registerType == 'fb') {
      avatarImage = userData['picture']?['data']?['url'];
    } else if (registerType == 'gg') {
      avatarImage = userData['picture'] as String?;
    } else if (registerType == 'apple') {
      avatarImage = userData['picture'] as String?;
    }

    developer.log('Id: $id', name: tag);
    developer.log('T√™n: $name', name: tag);
    developer.log('Email: $email', name: tag);
    developer.log('·∫¢nh ƒë·∫°i di·ªán: $avatarImage', name: tag);

    if (email != null && id != null && name != null && avatarImage != null) {
      final String randomPassword = _generateRandomPassword();

      // l∆∞u lo·∫°i ƒëƒÉng nh·∫≠p theo phi√™n
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      await prefs.setString('register_type', registerType);
      if (context.mounted) {
        loginSocial(
            context, email, randomPassword, name, registerType, avatarImage);
      }
      OneSignal.User.addEmail(email);
      OneSignal.login(email);
    } else {
      // C·∫≠p nh·∫≠t tag cho l·ªói c≈©ng d·ª±a tr√™n registerType
      final String errorTag = registerType == 'fb'
          ? 'FB_LOGIN.SUCCESS.ERROR'
          : (registerType == 'apple'
              ? 'APPLE_LOGIN.SUCCESS.ERROR'
              : 'GG_LOGIN.SUCCESS.ERROR');
      developer.log('Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt ƒë·ªÉ ƒëƒÉng nh·∫≠p', name: errorTag);
      _handleLoginIssue(
        message: 'Kh√¥ng l·∫•y ƒë∆∞·ª£c ƒë·∫ßy ƒë·ªß th√¥ng tin ng∆∞·ªùi d√πng',
        tag: errorTag,
      );
    }
  }

  void _handleLoginIssue({
    required String message,
    required String tag,
    Object? error, // Tham s·ªë t√πy ch·ªçn ƒë·ªÉ log chi ti·∫øt l·ªói n·∫øu c√≥
  }) {
    developer.log(message, name: tag, error: error);
  }

  Future<void> loginSocial(
      BuildContext context,
      String identity,
      String password,
      String displayName,
      String registerType,
      String avatarImage) async {
    try {
      // Hi·ªÉn th·ªã loading overlay
      LoadingOverlay.show(context);

      // ƒê√°nh d·∫•u ƒë·ªÉ kh√¥ng ·∫©n LoadingOverlay nhi·ªÅu l·∫ßn
      bool loadingHidden = false;

      void hideLoadingOnce() {
        if (!loadingHidden) {
          LoadingOverlay.hide();
          loadingHidden = true;
        }
      }

      await executeApiCall(
        apiCall: () => _authRepository.loginSocial(identity, password,
            displayName, registerType, avatarImage, context),
        context: context,
        onSuccess: () async {
          final token = user!.token!;
          final idUser = user!.idUser!;

          if (kDebugMode) {
            print("Token: $token");
            print("IdUser: $idUser");
            print("Password: $password");
          }

          await _saveToken(token);
          await _saveUserId(idUser);

          // T·∫°o danh s√°ch c√°c Future ƒë·ªÉ theo d√µi
          final futures = <Future>[];
          if (!context.mounted) return;
          // Th√™m c√°c t√°c v·ª• fetch d·ªØ li·ªáu v√†o danh s√°ch
          futures.add(Provider.of<UserProvider>(context, listen: false)
              .fetchUser(context));
          futures.add(Provider.of<ProductProvider>(context, listen: false)
              .getListProduct(context));

          final postProvider =
              Provider.of<PostProvider>(context, listen: false);
          // final rankProvider =
          //     Provider.of<RankProvider>(context, listen: false);
          //
          // futures.add(rankProvider.fetchRanksRevenue(context));
          // futures.add(rankProvider.fetchRankBusiness(context));

          futures.add(postProvider.fetchPostsFeatured(context));
          futures.add(postProvider.fetchPostsByUser(context));

          // Ch·ªù t·∫•t c·∫£ c√°c t√°c v·ª• ho√†n th√†nh
          await Future.wait(futures);

          // Connect to socket
          OneSignal.login(identity);
          socketService.connect(idUser);
          socketService.connectUserStatus();

          if (context.mounted) {
            // ·∫®n loading overlay
            hideLoadingOnce();
            context.go(AppRoutes.trangChu.replaceFirst(':index', '0'));
          } else {
            // ·∫®n loading overlay n·∫øu context kh√¥ng c√≤n h·ª£p l·ªá
            hideLoadingOnce();
            developer.log('Context kh√¥ng c√≤n h·ª£p l·ªá', name: 'FB_LOGIN.ERROR');
          }
        },
      );

      // N·∫øu c√≥ l·ªói, ƒë·∫£m b·∫£o ·∫©n loading
      if (errorMessage != null) {
        hideLoadingOnce();
      }
    } catch (e) {
      // ƒê·∫£m b·∫£o ·∫©n loading trong m·ªçi tr∆∞·ªùng h·ª£p l·ªói
      LoadingOverlay.hide();
      debugPrint("L·ªói ƒëƒÉng nh·∫≠p social: $e");
    }
  }
}

// H√†m t·∫°o m·∫≠t kh·∫©u ng·∫´u nhi√™n
String _generateRandomPassword() {
  const String upperCase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const String lowerCase = 'abcdefghijklmnopqrstuvwxyz';
  const String numbers = '0123456789';
  const String specialChars = '@';
  const int minLength = 8;

  final Random random = Random();
  final StringBuffer password = StringBuffer();

  // ƒê·∫£m b·∫£o √≠t nh·∫•t 1 k√Ω t·ª± t·ª´ m·ªói lo·∫°i
  password.write(upperCase[random.nextInt(upperCase.length)]);
  password.write(lowerCase[random.nextInt(lowerCase.length)]);
  password.write(numbers[random.nextInt(numbers.length)]);
  password.write(specialChars[random.nextInt(specialChars.length)]);

  // T·∫°o th√™m c√°c k√Ω t·ª± ng·∫´u nhi√™n ƒë·ªÉ ƒë·ªß ƒë·ªô d√†i t·ªëi thi·ªÉu
  const String allChars = upperCase + lowerCase + numbers + specialChars;
  for (int i = password.length; i < minLength; i++) {
    password.write(allChars[random.nextInt(allChars.length)]);
  }

  // X√°o tr·ªôn m·∫≠t kh·∫©u ƒë·ªÉ tƒÉng t√≠nh ng·∫´u nhi√™n
  final List<String> passwordList = password.toString().split('');
  passwordList.shuffle(random);
  return passwordList.join();
}
